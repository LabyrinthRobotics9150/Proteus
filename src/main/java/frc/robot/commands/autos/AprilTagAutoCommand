import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.ParallelRaceGroup;
import edu.wpi.first.wpilibj2.command.WaitUntilCommand;
import frc.robot.subsystems.CommandSwerveDrivetrain;
import frc.robot.subsystems.Elevator;

public class AprilTagAutoCommand extends Command {
    private final CommandSwerveDrivetrain drivetrain;
    private final Elevator elevator;

    public AprilTagAutoCommand(CommandSwerveDrivetrain drivetrain, Elevator elevator, VisionSubsystem limelight) {
        this.drivetrain = drivetrain;
        this.elevator = elevator;
    }

    @Override
    public Command get() {
        return Commands.deferred(() -> {
            Pose2d initialPose = drivetrain.getPose();

            return Commands.sequence(
                // Drive until AprilTag detected
                new ParallelRaceGroup(
                    drivetrain.applyRequest(() -> 
                        new SwerveRequest.FieldCentric()
                            .withVelocityX(0.5) // Adjust speed as needed
                            .withVelocityY(0)
                            .withRotationalRate(0)
                    ),
                    new WaitUntilCommand(() -> 
                        drivetrain.hasSeenAprilTag() // Placeholder method
                    )
                ),
                // Auto-align (placeholder)
                Commands.runOnce(() -> {/* Align command here */}),
                // Raise elevator to level 4
                new HoldAndReturnCommand(elevator, 3.90),
                // Score (placeholder)
                Commands.runOnce(() -> {/* Score command here */}),
                // Lower elevator
                new HoldAndReturnCommand(elevator, 0.0),
                // Return to starting position
                createReturnToStartCommand(initialPose)
            );
        });
    }

    private Command createReturnToStartCommand(Pose2d initialPose) {
        return Commands.sequence(
            drivetrain.applyRequest(() -> 
                new SwerveRequest.FieldCentric()
                    .withVelocityX(-0.5) // Drive back
                    .withVelocityY(0)
                    .withRotationalRate(0)
            ).until(() -> 
                drivetrain.getPose().getTranslation()
                    .getDistance(initialPose.getTranslation()) < 0.1 // Threshold
            ),
            drivetrain.applyRequest(() -> new SwerveRequest.Idle()) // Stop
        );
    }
}
